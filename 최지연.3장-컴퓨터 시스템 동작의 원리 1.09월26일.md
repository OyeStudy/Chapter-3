### 1. 컴퓨터 시스템의 구조	
컴퓨터 시스템의 구조는
- `내부장치` 인 CPU, 메모리와
- `외부장치` 인 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등으로 구성된다.(`입출력장치` 라고도 한다) 

컴퓨터는 **1)** 외부장치에서 내부장치로 데이터를 읽어와 **2)** 각종 연산을 수행한 후, **3)** 그 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다.

이 때, 컴퓨터 내부로 데이터가 들어오는 것은 입력(input), 컴퓨터 외부로 데이터가 나가는 것을 출력(output)이라고 한다. 

> #### 헷갈리기 쉬운 부분!  디스크도 컴퓨터의 '외부장치'
따라서, 디스크에서 내용을 <u>읽어</u> 컴퓨터 내부에서 어떤 연산을 한 후 디스크에 데이터를 <u>저장</u>했다면 컴퓨터 입장에서는 **입력과 출력**이 일어난 것이다. 

- 컨트롤러(controller)
메모리 및 입출력 장치 등의 각 하드웨어 장치에는 컨트롤러가 붙어있다. 컨트롤러를 일종의 `작은 CPU` 로서, 각 하드웨어 장치마다 존재하면서 이들을 제어한다. ex) XX를 제어하는 컨트롤러 -> XX컨트롤러

![](https://velog.velcdn.com/images/ddongpuri/post/f90cad0a-5b4a-4e75-99ef-79fba134a129/image.png)

### 2. CPU연산과 I/O연산
컴퓨터에서 `연산을 한다` == `CPU가 무언가 일을 한다` 이다.
입출력 장치들의 I/O 연산은 **입출력 컨트롤러**가 담당하고, 컴퓨터 내에서 수행되는 연산은 **메인 CPU**가 담당한다. 

- 이 때, 입출력 장치와 메인 CPU는 동시 수행이 가능하다. 

한편, 각 장치를 제어하기 위해 설치된 장치 컨트롤러는, 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리, **로컬버퍼(local buffer)** 를 가지고 있다. 

예를 들어, 프로그램B가 수행 중에 디스크에서 데이터를 읽어오라는 명령을 내리면, `디스크 컨트롤러`가 물리적인 디스크에서 내용을 읽어 이를 `로컬버퍼` 에 저장한다. 작업이 끝나면, 디스크 컨트롤러는 **`interrupt`** 를 발생시켜 CPU에 보고한다. 


### 3. 인터럽트의 일반적 기능

인터럽트에는 **하드웨어 인터럽트와 소프트웨어 인터럽트**가 있다. 
CPU의 서비스가 필요한 경우, CPU 옆에 있는 `인터럽트 라인` 에 신호를 보내서 인터럽트가 발생했음을 알려주는 방식은 둘다 동일하다.
- `하드웨어 인터럽트` 는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅하고,  
- `소프트웨어 인터럽트` 는 소프트웨어가 그 일을 수행한다. 
```
통상적으로 '인터럽트'라고 하면 하드웨어 인터럽트를 의미하고,
소프트웨어 인터럽트는 '트랩(trap)'이라는 용어로 주로 불린다.
```

발생한 인터럽트의 종류와는 상관없이, 일단 인터럽트가 발생하면 CPU는 하던 일을 멈추고, 운영체제 커널 내에서 해당 인터럽트의 처리를 위해 정의된 코드를 찾게 된다. 운영체제는 할 일을 쉽게 찾아가기 위한 <strong>인터럽트 벡터</strong>를 가지고 있다.
> - **인터럽트 벡터**
> 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있는 자료구조를 말한다. 실제 처리해야 할 코드는 '**인터럽트 처리루틴**' 또는 '**인터럽트 핸들러**' 라고 불리는 다른 곳에 정의된다.
> 
>
> - **인터럽트 처리루틴(Interrupt Service Routine : ISR)**
해당 인터럽트를 처리하는 **커널함수**. 운영체제 커널 내에 있는 인터럽트 처리루틴은 다양한 인터럽트에 대해 각각 처리해야 할 업무들을 정의하고 있다. 
```
예시) 디스크 컨트롤러가 인터럽트를 발생시킨 경우!
  -> 해당 인터럽트가 발생했을 때 수행하도록 정의된 코드를 찾아 수행한다. 
> 
디스크의 로컬버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달하고,
해당 프로그램이 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시해두는 일'을 수행한다.
```

 소프트웨어 인터럽트(trap)에 대해서 자세히 살펴보자 : 예외상황(exception)과 시스템콜(system call)
- 예외상황(exception) - 프로그램이 오류를 범한 경우
사용자 프로그램이 0으로 나누는 연산 등 <u>비정상적인 작업</u>을 시도하거나, 자신의 메모리 영역 바깥에 접근하려는 시도 등 <u>권한이 없는 작업</u>을 시도할 때 이에 대한 처리를 위해 발생시키는 인터럽트이다. 

- 시스템 콜(system call) - 커널함수 호출
사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 **서비스를 요청(커널함수 호출)**하는 방법이라고 볼 수 있다. 

### 4. 인터럽트 핸들링
인터럽트 핸들링이란, 인터럽트가 발생한 경우에 처리해야 할 일의 절차를 의미한다.

프로그램 A가 실행되고 있을 때, 인터럽트가 발생하면 실행 중이던 **A의 현재 상태**(프로그램이 실행 중이던 코드의 메모리 주소와 레지스터값, 하드웨어 상태 등)를 먼저 **저장**한다. 

CPU에서 명령이 실행될 때에는 CPU 내부에 있는 임시 기억장치인 레지스터(register)에 데이터를 읽거나 쓰면서 작업을 하는데, 이때 인터럽트가 발생해 새로운 명령을 실행하면 기존의 레지스터값들이 지워지게 되므로 CPU 내의 이러한 상태를 저장해두어야 한다. 

운영체제는 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 `프로세스 제어블록(Process Control Block : PCB)` 이라는 자료구조를 둔다. PCB는 각각의 **프로그램마다 하나씩** 존재한다. 

정리하자면, 
```
=> 프로그램 A 실행 중 인터럽트 발생 -> 프로그램 A의 실행 상태를 PCB에 저장 
-> CPU의 제어권이 인터럽트 처리루틴으로 넘어가 인터럽트 처리
-> 인터럽트 처리가 끝나면 저장된 상태를 PCB로부터 CPU상에 복원, 
   해당 상태부터 실행이 이어진다. 
```

### 5. 입출력 구조!

[](https://velog.velcdn.com/images/ddongpuri/post/93ef6f41-822e-48f7-9b40-8f8040af16e5/image.png)


### 6. DMA
원칙적으로 메모리는 CPU에 의해서만 접근할 수 있는 장치다. 따라서 CPU 외의 장치가 메모리의 데이터에 접근하기 위해서는 CPU에게 인터럽트를 발생시켜 CPU가 이를 대행하는 식으로만 가능하다. 

한편, 모든 메모리 접근 연산이 CPU에 의해서만 이루어질 경우 입출력 장치가 메모리 접근을 원할 때마다 인터럽트에 의해 CPU의 업무가 방해를 받게 되어 **CPU 사용의 효율성이 저하**되는 문제가 발생한다.

![](https://velog.velcdn.com/images/ddongpuri/post/a5507a4b-1e9c-439a-a030-c1b413bc6a99/image.png)

이러한 비효율성을 극복하기 위해 CPU 이외에 메모리 접근이 가능한 장치를 하나 더 두는 경우가 많은데, 이와 같은 장치를 **DMA**(Direct Memory Access)라고 부른다.

- DMA
DMA는 일종의 컨트롤러로서, CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할을 한다.

DMA를 사용하게 되면, <u>로컬버퍼에서 메모리를 읽어오는 작업</u>을 CPU가 담당하는 것이 아니라 **DMA가 대행** 한다. 

DMA는 바이트(byte) 단위가 아니라 블록(block)이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜서 해당 작업의 완료를 알려준다. 

![](https://velog.velcdn.com/images/ddongpuri/post/a953114d-a703-4147-991c-3af77f3a7933/image.png)

결과적으로, DMA를 통해 CPU에 발생하는 인터럽트 발생 빈도를 줄여 CPU의 효율적인 관리와 빠른 입출력 연산 수행을 달성할 수 있다. 
